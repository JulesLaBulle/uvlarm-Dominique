#!/usr/bin/python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from sensor_msgs.msg import PointCloud
from geometry_msgs.msg import Point32
from kobuki_ros_interfaces.msg import BumperEvent
import time
import math
import sys

# Ros Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init(args=sys.argv)
    node = Node('basic_move')

    # Initialize our control:
    control = StraightCtrl()
    control.initializeRosNode(node)

    # Infinite Loop:
    rclpy.spin(node)

    # Clean end
    node.destroy_node()
    rclpy.shutdown()

# Ros Node Class:
class StraightCtrl:
    def __init__(self):
        self._logger = None
        self._pubVelocity = None
        self._subToScan = None
        self._timForCtrl = None
        
        self._obs_left = False
        self._obs_right = False
        
        self._nbr_points_right = 0
        self._nbr_points_left = 0
        
        self._bumper_state = None
        self._is_reversing = False  # Drapeau pour indiquer si le robot est en train de reculer


    def initializeRosNode(self, rosNode):
        # Get logger from the node:
        self._logger = rosNode.get_logger()

        # Initialize publisher:
        self._pubVelocity = rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        # Initialize scan callback:
        self._subToPoints = rosNode.create_subscription(
            PointCloud, '/points',
            self.scan_callback, 10
        )

        # Initialize control callback:
        self._timForCtrl = rosNode.create_timer(
            0.05, self.control_callback
        )
        
        # Initialize bumper callback
        self._bumper_subscriber = rosNode.create_subscription(
            BumperEvent, '/events/bumper',
            self.bumper_callback, 10
        )

    def scan_callback(self, pointCloud):
        self._nbr_points_right = 0
        self.nbr_points_left = 0
        self._obs_left = False
        self._obs_right = False
        for point in pointCloud.points:
            if point.y > 0:
                self._obs_left = True 
                self._nbr_points_left += 1
            else:
                self._obs_right = True
                self._nbr_points_right += 1

     
        self._logger.info(f"Obstacle Left: {self._obs_left}, Obstacle Right: {self._obs_right}")

    def control_callback(self):
        # Initialisation des vitesses
        linear_velocity = 0.0
        angular_velocity = 0.0

        if self._bumper_state is not None and not self._is_reversing:
            # Reculer doucement pendant 1 seconde si le bumper est activé
            self._is_reversing = True  # Activer le drapeau pour empêcher des reculs multiples
            linear_velocity = -0.2  # Vitesse de recul
            angular_velocity = 0.0
            self._logger.info(f"Bumper activé ({self._bumper_state}). Recule doucement.")

            # Publier la commande de recul
            velocity_msg = Twist()
            velocity_msg.linear.x = linear_velocity
            velocity_msg.angular.z = angular_velocity
            self._pubVelocity.publish(velocity_msg)

            # Attendre une seconde
            time.sleep(2)

            # Réinitialiser l'état du bumper
            self._bumper_state = None
            self._is_reversing = False  # Désactiver le drapeau après le recul
            return  # Arrêter le callback ici après le traitement du bumper

        # Logique de contrôle normale basée sur les obstacles détectés
        if self._obs_right and self._obs_left:
            # Obstacles des deux côtés : rotation sur place pour éviter
            if self._nbr_points_left > self._nbr_points_right
                linear_velocity = 0.0
                angular_velocity = -0.8
            else:
                linear_velocity = 0.0
                angular_velocity = 0.8
                
            self._logger.info("Obstacles détectés des deux côtés. Rotation pour éviter.")
        
        
        elif self._obs_right:
            # Obstacle à droite : tourne à gauche
            linear_velocity = 0.0
            angular_velocity = 0.8
            
            self._logger.info("Obstacle détecté à droite. Rotation à gauche.")
        elif self._obs_left:
            # Obstacle à gauche : tourne à droite
            linear_velocity = 0.0
            angular_velocity = -0.8
            
            self._logger.info("Obstacle détecté à gauche. Rotation à droite.")
        else:
            # Aucun obstacle : avance tout droit
            linear_velocity = 0.3
            angular_velocity = 0.0
            
            self._logger.info("Aucun obstacle détecté. Avance tout droit.")

        # Création du message Twist pour envoyer les commandes au robot
        velocity_msg = Twist()
        velocity_msg.linear.x = linear_velocity
        velocity_msg.angular.z = angular_velocity

        # Publication des commandes de vitesse
        self._pubVelocity.publish(velocity_msg)


    def bumper_callback(self, msg):
        if msg.bumper == BumperEvent.LEFT:
            self._bumper_state = 0
        elif msg.bumper == BumperEvent.CENTER:
            self._bumper_state = 1
        elif msg.bumper == BumperEvent.RIGHT:
            self._bumper_state = 2
        else:
            self._bumper_state = None

# Go:
if __name__ == '__main__':
    main()
